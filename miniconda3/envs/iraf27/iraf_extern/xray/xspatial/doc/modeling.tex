%\input skeleton.tex
\def\version{Version 1.0 --- 11/22/88}
\def\chapter{Spatial --- Modeling}
%\chapterhead{Spatial Modeling}
\chapterhead{II.~Spatial Modeling}
\@{Overview}

Conceptually the correct way to undertake spatial modeling is
to produce an energy-dependent spatial model that is folded through
the combined energy and spatial telescope/detector response and compared with data.  This
automatically takes care of the energy-dependent vignetting and
the point response function of the detector.  The input model
could consist of any combination of point sources, extended sources of
given functional shapes, and a spatially-constant value for diffuse
X-ray emission.

In practice, a reasonable tool is the ability to make a spatial array
composed of point sources or extended sources of user-selected energy
distributions which have been convolved with the detector point
response function (PRF) for a user-selected
energy band between $E_{low}$ and $E_{hi}$.  The user
may wish subsequently to divide by the vignetting
function for the same energy band, and a constant which represents
live time, and compare with an image of observed data, possibly
applying
$\chi^2$ to evaluate the best overall normalization and goodness of
fit. Since the vignetting correction is energy
dependent, and the user may wish to model several sources with
different spectra into one model image, a nice way to proceed may be
to store the output in 3D IRAF images, where the 3rd dimension
contains a grid of $n$ energy bins equally spaced between $E_{low}$
and $E_{hi}$, where the user has specified $n$.  The header of the
output 3D image would contain the values for the central energies of
the $n$ bins.
The vignetting could then be applied to each energy bin in turn, and
the 3D image could be collapsed to a 2D spatial array for display.

The modeling function will allow the user to select from preselected
models which will include a delta function or extended function (such
as a King model), and to convolve them with a PRF which may be a
normalized Gaussian of user-specified width or
a tabulated or analytical energy-dependent PRF.  The output should
be in the form of a (real) IRAF image file, or the output array
may be directed to be added to a
pre-existing IRAF image file of the same dimensions.

\@{User Input}

The user must specify a choice of energy range for the output model,
$E_{low}$, $E_{hi}$ and $n$, a
choice of model, and a choice of PRF.  The user will specify an
intensity, $A$, for the source.  The position of the model
source in the output array, $x_i, y_i$, must be
chosen, along with the spatial dimensions of the output image.
The user will probably wish ultimately to compare the model with
a particular data set.  It would be a nice feature if the
name of this data file could be specified as an input to the modeling
task.  The modeling task would
copy the pointing direction, roll and
livetime in making the header for the output file, and use the spatial
dimensions of the data file for the modeling and output file, as long as the
output file was not already extant.
Furthermore, the user should select an energy
distribution function for the source from those available.

\@{Model Functions}

\**Delta-function

\**Gaussian of user-supplied $\sigma$.  $\sigma$ will be
in units of numbers of pixels. 

$$f =  \exp {\left[ - r^2 \over 2 \sigma^2\right]}$$

\**King Profile of user-specified $p$, and width $r_o$.

$$f =  \left( 1 + \left({r \over r_o}\right)^2 \right)^{-p}$$

\**Power law of user-specified $p$ and width $r_o$.

$$f =  \left( 1 + {r \over r_o} \right)^{-p}$$

\@{PRF}

The PRF may be Gaussian with input similar to above, or the user may
specify that the calibration PRF as a function of energy is
used.  The calibration PRF may exist in the form of an expression, or
a look-up table. (What is it for the IPC?)

\@{Energy Distribution Functions}

The user may select one of a few simple normalized energy
distributions. (Do we need more than these?)  The value of $f_i$ for
bin $i$ with central energy $E_i$ is as follows.

\**Power law model with user-specified energy index $\alpha$.

$$f_i = {E_i ^{-(\alpha + 1)} \over \sum_{i=1}^n E_i ^{-(\alpha + 1)}}  $$

\**Exponential model with user-specified temperature (in keV).

$$f_i = {\exp \left( - {E_i \over T }\right) 
\over \sum_{i=1}^n \exp \left( - {E_i \over T }\right)} $$

\@{Convolution}

The model and PRF must be mapped into arrays of the same pixel size as
that which the user specified for the output image.
The model and PRF are convolved, as for smoothing.  If the model is a
delta function, no convolution is required, and the result is merely
the PRF.  The convolution must be done separately for each of the $n$
energy bands if the PRF is a function of energy.  If there is no energy
dependent of the PRF, the convolution need only be done once.

\@{Apply Energy Distribution Function and Normalization}

Every pixel in the convolved output array should be multiplied by $f_i$,
where the index $i$ corresponds to the number of the energy bin, $i =
1, n$.    Every pixel in the convolved output array should also be
multiplied by the user-input normalization, $A$.  The convolved
normalized output array should be shifted so that the source is
centered on the user-specified pixel $x_i, y_i$, before adding to
the output IRAF image file.

\@{Output}

The output should be a 2D (if $n = 1$) or 3D IRAF image file.  The header should
contain
such values as the array size, pointing direction, roll angle,
livetime, and the central energies of the $n$ bins.

\@{Fitting}

The user may subsequently take the output model image and perform various tasks on
it.
One task may be to divide by the vignetting array which is correct for
the energy-bands and other information in the model image (as read in
the model header).  The user may wish to add a constant
or another image to the resulting model image (to account for particle
background).  Finally the user may wish to collapse the image in
energy and perform a $\chi^2$ test
between the model and another IRAF image containing data, and find the
best overall normalization in so doing.

 
\vfill\eject






