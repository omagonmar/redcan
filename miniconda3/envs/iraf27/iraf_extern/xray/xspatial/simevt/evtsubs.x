# $Header
# $Log
#
# Module:       evtsubs.x
# Project:      PROS -- ROSAT RSDC
# Purpose:      Procedures used in generating simulated events
# Description:  includes subroutines get_bkg, calc_gauss_prf,
#               calc_hri_prf, get_integral, get_event
# Copyright:    Property of Smithsonian Astrophysical Observatory
#               1994.  You may do anything you like with this
#               file except remove this copyright
# Modified:     {0} KRM -- initial version -- 8/94
#
# -----------------------------------------------------------------------

include "simevt.h"
include <math.h>

# -----------------------------------------------------------------------
#
# get_bkg
#
# Input 	qpinfo	: qpoe info structure
#		bkgcts  : number of bkgd counts to generate
#		ofd	: output file descriptor
#
# Description : Generates "bkgcts" number of events, where the 
# x and y coordinates of the events are derived with the system
# random number generator urand.  The calling routine seeds the 
# function with a clock time.  The seed is required for successive
# calls to the function and is stored in the common block "ran.com".
#
# NOTE : The urand function returns a real value between 0.0 and 1.0
# This is coerced to a double value, so that the double precision of
# the original C code is preserved.  
#
###

procedure get_bkg(qpinfo, bkgcts, ofd)

pointer qpinfo
int bkgcts
int ofd

int xpos, ypos		# event coordinates

int ii			# loop invariant

double ran_num		# random value

real urand()		# random number generator

include "ran.com"

begin

    do ii = 1, bkgcts {

	# initialize xpos and ypos to non-sensical values

	xpos = -1
	ypos = -1
	
	# get an X value

	while ( (xpos < SIM_QPLL(qpinfo)) || (xpos > SIM_QPUL(qpinfo)) ) {

	    ran_num = double(urand(seed))
	    xpos = int(SIM_QPUL(qpinfo)*ran_num)
	}

	while ( (ypos < SIM_QPLL(qpinfo)) || (ypos > SIM_QPUL(qpinfo)) ) {

	    ran_num = double(urand(seed))
	    ypos = int(SIM_QPUL(qpinfo)*ran_num)
	}

	call fprintf(ofd, "%d   %d \n")
	  call pargi(xpos)
 	  call pargi(ypos)
    }

end
	
# -----------------------------------------------------------------------
#
# calc_gauss_prf
#
# Input : 	sigma 	- sigma value in pixels
#		r	- distance from center in pixels
#
# Output :	intr 	- integral of the GAUSS PRF from 0 to r
#
###

double procedure calc_gauss_prf(sigma, r)

double sigma
double r

double intr

double num	# numerator
double denom	# denominator

begin

    num = -r*r

    denom = 2.d0*sigma*sigma

    intr = (1.d0 - exp(num/denom))

    return(intr)

end

# -----------------------------------------------------------------------
# 
# calc_hri_prf
#
# Input :	offang 	- offaxis angle in arcminutes
#		r 	- distance from center in pixels
#
# Output :      intr    - integral of the HRI PRF from 0 to r
#
# Algorithm :   The description of the HRI PRF is taken from the
# report "The ROSAT High Resolution Imager (HRI)" by David et. al.,
# December 1993.  The on-axis equation is given on page 6.  The 
# values for a1, a2, a3, s1, and s3 were generated by FAP so that 
# we can use values of r in units of pixels.
#
# The Value of s2 as a function of offaxis angle is taken from page
# 13.  This equation gives s2 in units of arc seconds which are then
# converted to pixels.
#
###

double procedure calc_hri_prf(offang, r)

double offang
double r

double intr

double a1, a2, a3
double s1, s2, s3
double e1, e2, e3
double rarg

begin

    # initialize values

    a1 = 4.400e-3
    a2 = 8.208e-4
    a3 = 5.333e-6
    
    s1 = 4.372d0
    s3 = 63.38d0

    # calculate the value of s2 from the given offaxis angle

    s2 = 3.3d0 + 0.019d0*offang - 0.016d0*(offang**2) + 
	        0.0044d0*(offang**3)

    # convert to value in pixels

    s2 = 2.d0*s2

    # now do the math ...

    rarg = r*r/2.d0

    e1 = TWOPI*a1*s1*s1*(1.d0 - exp(-rarg/(s1*s1)))
   
    e2 = TWOPI*a2*s2*s2*(1.d0 - exp(-rarg/(s2*s2)))

    rarg = r/s3

    e3 = TWOPI*a3*s3*s3*(1.d0 - exp(-rarg) - rarg*exp(-rarg))

    intr = e1 + e2 + e3

    return (intr)

end
    
# -----------------------------------------------------------------------
#
# get_integral
#
# Input : 	type	- source type, code indicating which 
#			  PRF function to call
#		par 	- either offaxis angle or sigma 
#		dist	- distance from center in pixels
#
# Output : 	prf 	- integral of relevant PRF
#
###

double procedure get_integral(type, par, dist)

int type
real par
double dist

double prf

double calc_hri_prf()
double calc_gauss_prf()

include "hri.com"

begin 

    if ( type == HRI_PRF ) {
	prf = calc_hri_prf(double(par), dist)
	prf = prf/hri_norm
    }

    else if ( type == GAUSS_PRF ) {
	prf = calc_gauss_prf(double(par), dist)
    }

    else {
	call error(1, "Unknown source type encountered!")
    }

    return (prf)

end

# -----------------------------------------------------------------------
# 
# get_event
#
# Input : 	srcinfo - source info structure
#		qpinfo  - qpoe info structure
#
# Output : 	evtx, evty - coordinates of event
#
###

procedure get_event(srcinfo, qpinfo, evtx, evty)

pointer srcinfo
pointer qpinfo

int evtx
int evty

double r, azimuth	 # radius and angle

double Z, z1, z2, tol    # values to pass to dzbrent function

double dzbrent()
real urand()

include "ran.com"

begin

    # initialize variables for dzbrent call

    z1 = 0.d0
    z2 = MAX_RT
    tol = 1.0e-3

    # initialize coordinates to nonsensical numbers

    evtx = -1
    evty = -1

    while ( (evtx < SIM_QPLL(qpinfo)) || (evtx > SIM_QPUL(qpinfo)) ||
	    (evty < SIM_QPLL(qpinfo)) || (evty > SIM_QPUL(qpinfo)) ) {
	
	Z = double(urand(seed))

      	# get a radius, or distance from source center

	r = dzbrent(SRCTYPE(srcinfo), SRCPAR(srcinfo), Z, z1, z2, tol)

	# calculate an angle

	azimuth = TWOPI*(double(urand(seed)))

	# now calculate the position of the event

	evtx = nint(SRCX(srcinfo) + r*cos(azimuth))
	evty = nint(SRCY(srcinfo) + r*sin(azimuth))

    }

end

	
