#$Header: /home/pros/xray/lib/pros/RCS/mskg2s.gx,v 11.0 1997/11/06 16:20:41 prosb Exp $
#$Log: mskg2s.gx,v $
#Revision 11.0  1997/11/06 16:20:41  prosb
#General Release 2.5
#
#Revision 9.0  1995/11/16 18:28:00  prosb
#General Release 2.4
#
#Revision 8.0  1994/06/27  13:46:41  prosb
#General Release 2.3.1
#
#Revision 7.0  93/12/27  18:10:04  prosb
#General Release 2.3
#
#Revision 6.0  93/05/24  15:45:14  prosb
#General Release 2.2
#
#Revision 5.0  92/10/29  21:17:07  prosb
#General Release 2.1
#
#Revision 4.0  92/04/27  13:49:17  prosb
#General Release 2.0:  April 1992
#
#Revision 3.0  91/08/02  01:00:53  wendy
#General
#
#Revision 2.0  91/03/07  00:07:14  pros
#General Release 1.0
#
#
# MSK_G2S -- fill a 2-D buffer using MIO calls
# the mask is used as a filter but is otherwise ignored
#

include <mach.h>
include <pmset.h>
include <error.h>

procedure msk_g2s$t(mp, buf, xdim, ydim, ncols, nrows)

pointer	mp		# i: mask handle
PIXEL	buf[ARB]	# o: array to hold data
int	xdim, ydim	# i: dim of array
int	nrows, ncols	# i: size of buffer

PIXEL	val		# l: value at this pixel
int	i		# l: loop counter
int	status		# l: status flag for mio call
int	mval		# l: value of integer mask from mio call
int	npix		# l: size of returned pp array
int 	yoffset		# l: offset into buffer for this line
int	xoffset		# l: offset into buffer within this line
int	offset		# l: combo of xoffset, yoffset into buf
int	xblock, yblock	# l: blocking factors
long	v[PM_MAXDIM]	# l: vector from mio call
pointer	pp		# l: pixel pointer for mio call

$if( datatype == s )
int mio_glsegs()	# l: mio get seg call
$else $if( datatype == i )
int mio_glsegi()	# l: mio get seg call
$else $if( datatype == l )
int mio_glsegl()	# l: mio get seg call
$else $if( datatype == r )
int mio_glsegr()	# l: mio get seg call
$else $if( datatype == d )
int mio_glsegd()	# l: mio get seg call
$else $if( datatype == x )
int mio_glsegx()	# l: mio get seg call
$endif $endif $endif $endif $endif $endif

begin
	status = OK
	xblock = xdim/ncols
	yblock = ydim/nrows
	while( status != EOF ){
	    # get next line segment
$if( datatype == s )
	    status = mio_glsegs(mp, pp, mval, v, npix)
$else $if( datatype == i )
	    status = mio_glsegi(mp, pp, mval, v, npix)
$else $if( datatype == l )
	    status = mio_glsegl(mp, pp, mval, v, npix)
$else $if( datatype == r )
	    status = mio_glsegr(mp, pp, mval, v, npix)
$else $if( datatype == d )
	    status = mio_glsegd(mp, pp, mval, v, npix)
$else $if( datatype == x )
	    status = mio_glsegx(mp, pp, mval, v, npix)
$endif $endif $endif $endif $endif $endif
	    if( status != EOF ){
		# determine the line number in which this pixel lies
		yoffset = (v[2]-1)/yblock
		# skip last rows if nrows does not divide ydim evenly
		if( yoffset < nrows ){
		    # deposit each pixel in this line segment
		    do i=0, (npix-1){
$if( datatype == s )
			if( Mems[pp+i] ==0 )
			    next
			else
			    val = Mems[pp+i]
$else $if( datatype == i )
			if( Memi[pp+i] ==0 )
			    next
			else
			    val = Memi[pp+i]
$else $if( datatype == l )
			if( Meml[pp+i] ==0 )
			    next
			else
			    val = Meml[pp+i]
$else $if( datatype == r )
			if( abs(Memr[pp+i]) <EPSILONR )
			    next
			else
			    val = Memr[pp+i]
$else $if( datatype == d )
			if( abs(Memd[pp+i]) <EPSILOND )
			    next
			else
			    val = Memd[pp+i]
$else $if( datatype == x )
			val = Memx[pp+i]
$endif $endif $endif $endif $endif $endif
			# determine the offset into this line
		        xoffset = (v[1]+i-1)/xblock
			# skip last cols if ncols does not divide xdim evenly
		        if( xoffset < ncols ){
		            offset = yoffset * ncols + xoffset + 1
		            buf[offset] = buf[offset] + val
			}
		    }
		}
	    }
	}
end
