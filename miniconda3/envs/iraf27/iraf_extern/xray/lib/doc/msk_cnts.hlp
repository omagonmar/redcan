#$Header: /home/pros/xray/lib/doc/RCS/msk_cnts.hlp,v 11.0 1997/11/06 16:23:00 prosb Exp $
#$Log: msk_cnts.hlp,v $
#Revision 11.0  1997/11/06 16:23:00  prosb
#General Release 2.5
#
#Revision 9.0  1995/11/16 18:31:02  prosb
#General Release 2.4
#
#Revision 8.0  1994/06/27  14:35:54  prosb
#General Release 2.3.1
#
#Revision 7.0  93/12/27  18:19:43  prosb
#General Release 2.3
#
#Revision 6.0  93/05/24  16:01:11  prosb
#General Release 2.2
#
#Revision 5.0  92/10/29  21:20:55  prosb
#General Release 2.1
#
#Revision 4.0  92/04/27  14:10:01  prosb
#General Release 2.0:  April 1992
#
#Revision 3.0  91/08/02  00:47:49  prosb
#General Release 1.1
#
#Revision 2.0  91/03/07  00:35:36  pros
#General Release 1.0
#
.help msk_cnts Jan89 PROS_Library
NAME
.in 4
msk_cnts - determine counts and area of mask regions
.sp
.in -4
USAGE
.in 4
call msk_cnts(mp, dtype, counts, area, min, max)
.sp
.in -4
PARAMETERS
.in 4
.nf
Input Arguments:
	mp		pointer		mio handle
	dtype		int		data type of image assoc. with mio
	min		int		min region id in region mask
	max		int		max region id in region mask

Output Arguments:
	counts		double		array to hold counts
	area		double		array to hold areas
.fi
.sp
.in -4
DESCRIPTION
.in 4
The subroutine msk_cnts determines the counts and area (in pixels)
for each region in a mask.  The counts and area arrays must be of
dimension:
.nf

	dim =  max - min + 1

.fi
or greater. The region id is mapped to a buffer offset by:
.nf

	offset = region - min + 1

.fi
The min and max region value can be determined by means of the rg_pmvallims
subroutine.  (The current implementation of rg_pmcreate, which creates
a region mask, the min is set to 1.  However, it cannot be guaranteed
that this will be the case for all masks, since not all masks are created
by this routine.) Msk_cnts gives an error if a mask value is out of range.

Msk_cnts uses the mio_glseg call corresponding to the input data type
to get the number of counts in each region
segment then and increments the appropriate elementof the double precision
output array.  (Using the
mio call corresponding to the file data type saves considerable processing
time.)
Therefore, msk_cnts call requires an mio handle as input.  This handle is
returned by an mio open call such as mio_openo.  If one is using the msk
library function msk_open to combine a region mask and an exposure mask,
it is necessary to call mio_openo after msk_open to get this mio handle
(see example below).
.sp
.in -4
EXAMPLES
.in 4
ex. The following example shows how msk_cnts is used in conjunction with
other msk routines such as msk_open and msk_disp.  This code, adapted from
imcnts, counts up photons in an image, filtering through a region mask and
an exposure mask.
.in 8
.nf
include <ctype.h>
include <imhdr.h>
include <pmset.h>

include "../../lib/ext.h"

procedure cntphotons()

char	simage[SZ_FNAME]	# source image name
char	sregion[SZ_FNAME]	# source region descr
char	sexposure[SZ_FNAME]	# source exposure file
int	smin, smax		# min and max for source regions
int	sindices		# total indices for source regions
real	sthresh			# source threshold for exposure
pointer	sim 			# source image pointer
pointer	spm			# source pixel mask pointer
pointer	smp			# source mask I/O pointer
pointer	stitle			# source region summary pointer
pointer	scounts			# counts in source
pointer	sarea			# area in source
pointer	sp			# stack pointer

bool	strne()			# string compare
real	clgetr()		# get a real param
pointer	immap()			# open an image
pointer	msk_open()		# open a region and/or exp. mask
pointer	mio_openo()		# open a pixel mask for MIO

begin
  # mark the stack
  call smark(sp)
  
  # init some variables
  stitle = 0

  # get source information
  call clgstr("source", simage, SZ_FNAME)

  # get exposure stuff for source
  call clgstr("exp", sexposure, SZ_FNAME)
  call rootname(simage, sexposure, EXT_EXPOSURE, SZ_FNAME)
  if( strne(sexposure, "NONE") ){
	sthresh = clgetr("thresh")
	if( sthresh < 0.0 )
	    call error(1, "exposure threshold must be >=0")
  }

  # open the source image
  sim = immap(simage, READ_ONLY, 0)
  # open the region and/or exposure
  spm = msk_open(sregion, sexposure, sthresh, sim, stitle)
  # open the source mask file for MIO
  smp = mio_openo(spm, sim)

  # make sure we have a 1D or 2D image
  if( IM_NDIM(sim) > 2 )
	call error(1, "source image dimensions must be <= 2")  
  stype = IM_PIXTYPE(sim)

  # display the regions
  call msk_disp("SIGNAL", simage, Memc[stitle])

  # count up all photons - this is where all the work is done!!!
  call rg_pmvallims(spm, smin, smax)
  sindices = smax - smin + 1
  call salloc(scounts, sindices, TY_DOUBLE)
  call salloc(sarea, sindices, TY_DOUBLE)
  call msk_cnts(smp, stype, Memd[scounts], Memd[sarea], smin, smax)

  # display the source and bkgd counts
  call cnt_rawdisp("SIGNAL DATA",
	Memd[scounts], Memd[sarea], sindices)

  # close source MIO file
  call mio_close(smp)
  # close source pixel mask
  call pm_close(spm)
  # close source image
  call imunmap(sim)

  # free up stack space
  call sfree(sp)

end
.fi
.sp
.in -12
BUGS
.in 4
This routine probably should be one of a family of <silrdx> routines that
allow one to choose the data type of the counts and area arrays.

The pointer to the title summary must be set to zero in the calling routine.
.in -4
.sp
SEE ALSO
.in4
msk_open (which combines a region mask and an exposure mask into a
single mask), msk_g2s (which fills a 2-D buffer with data through a mask), and
msk_disp (which displays region information)


