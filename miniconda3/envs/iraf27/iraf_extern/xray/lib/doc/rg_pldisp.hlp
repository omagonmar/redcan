#$Header: /home/pros/xray/lib/doc/RCS/rg_pldisp.hlp,v 11.0 1997/11/06 16:23:16 prosb Exp $
#$Log: rg_pldisp.hlp,v $
#Revision 11.0  1997/11/06 16:23:16  prosb
#General Release 2.5
#
#Revision 9.0  1995/11/16 18:31:21  prosb
#General Release 2.4
#
#Revision 8.0  1994/06/27  14:36:24  prosb
#General Release 2.3.1
#
#Revision 7.0  93/12/27  18:20:16  prosb
#General Release 2.3
#
#Revision 6.0  93/05/24  16:01:45  prosb
#General Release 2.2
#
#Revision 5.0  92/10/29  21:21:25  prosb
#General Release 2.1
#
#Revision 4.0  92/04/27  14:10:56  prosb
#General Release 2.0:  April 1992
#
#Revision 3.0  91/08/02  00:47:58  prosb
#General Release 1.1
#
#Revision 2.0  91/03/07  00:35:58  pros
#General Release 1.0
#
.help rg_pldisp Apr89 REGIONS_Library
NAME
.in 4
rg_pldisp - display mask values in a mask
.sp
.in -4
USAGE
.in 4
call rg_pldisp(pl, ncols, nrows, x1, x2, y1, y2)
.sp
.in -4
PARAMETERS
.in 4
.nf
Input Arguments:
	pl	pointer		pointer of open and filled or loaded pl or pm
	ncols	int 		number of columns to use for display
	nrows	int		number of rows to use for display
	x1	int		- if >0, use as first x coord of x subsection
				- if 0, use actual x extent of mask values
				- if -1, show full width of image field
	x2	int		last x coord (if x1 is specifies subsection)
	y1	int		- if >0, use as first y coord of y subsection
				- if 0, use actual y extent of mask values
				- if -1, show full height of image field
	y2	int		last y coord (if y1 is specifies subsection)

Output Arguments:
	none
.fi
.sp
.in -4
DESCRIPTION
.in 4
The function rg_pldisp displays the mask values of a pl mask. It will
sub-sample large masks so as to be able to display the specified mask area
within the specified number of columns.  The row number is given at the left,
and the last two digits of the column number appear (10'a above 1's) at the
bottom.

The area of the mask to be displayed is given by the x1, x2, y1, y2 parameters.
These parameters can be used like a standard IRAF subsection specification.
x1 and y1 must be greater than 0 (as would always be the case anyway).  If
x1 is 0, rg_pldisp uses rg_pllims to determine the extent of all actual masks
(ignoring empty columns at the sides), and limits it display to that range.
If x1 is given as -1, rg_pldisp uses the entire image field (physical width of
the mask), regardless of empty columns or x2.  y1 works the same as x1,
specifying the extent in y (height).  If a subsection is given by one pair,
while the other axis is to use the actual mask extent, the extent determination
applies within the given subsection.  For example, suppose x1 is 0, while y1 is
100 and y2 is 200.  rg_pldisp, will check the limits of x in the rows from 100
to 200.  Suppose the mask limits in that range is determined to be 63 for the
lowest x and 211 for the heighest x.  If there is a mask at x=5, y=87, this
will not affect the x extent, as it is outside the specified y subsection.
See help for rg_pllims for a simple explanation of how this works.
.sp
.in -4
EXAMPLES
.in 4
ex. The following example shows how rg_pldisp is used in conjunction with
other routines such as rg_plcreate.  This code, adapted from plcreate, creates
and stores either a pl or pm region mask.  Display is an option.  The mode
option has a system default of "zoom" for which get_plims sets x1, x2, y1, y2
to 0, 0, 0, 0.
.in 8
.nf
include	<imhdr.h>
include <error.h>
include <plset.h>
include <pmset.h>

include "../../lib/ext.h"
include "../../lib/plhead.h"

# define max dimensions of the mask we create
define MAX_DIMS	2

procedure t_plcreate()

char	plname[SZ_FNAME]	# l: name of output PLIO file
char	imname[SZ_PATHNAME]	# l: name of input reference image file
char	region[SZ_FNAME]	# l: region descriptor
char	tempname[SZ_FNAME]	# l: temp mask name
char	s[SZ_PLHEAD]		# l: plio header string
char	dmode[SZ_LINE]		# l: mode of plio display (zoom, etc.)
bool	clobber			# l: clobber old mask

int	doimage			# l: flag we have a reference image
int	disp			# l: display mask
int	ncols			# l: columns to display
int	nrows			# l: rows to display
int	axislen[MAX_DIMS+1]	# l: axis lengths + 1 as a buffer
int	ndims			# l: number of dims specified by user
int	nchar			# l: return from ctoi
int	ip			# l: ctoi index
int	x1, y1, x2, y2		# l: rg_pldisp parameters
pointer	im			# l: reference image pointer
pointer	pl			# l: pixel list pointer
pointer	title			# l: region summary

int	clgeti()		# get int param
int	imaccess()		# image file existence
int	ctoi()			# char to int
bool	clgetb()		# get boolean
bool	streq()			# string compare
int	rg_ftype()		# rg file type: plio or region
pointer	rg_plcreate()		# create pixel mask
pointer	rg_pmcreate()		# create pixel mask
pointer	immap()			# open an image

begin
	# init some variables
	title = 0

	# get the parameters
	call clgstr ("region", region, SZ_FNAME)
	call clgstr ("image", imname, SZ_FNAME)
	call clgstr ("mask", plname, SZ_FNAME)
	clobber = clgetb ("clobber")
	disp = clgeti ("display")
	if( disp >1 ){
	    call clgstr("mode", dmode, SZ_LINE)
	    ncols = clgeti("ncols")
	    nrows = clgeti("nrows")
	    call get_plims(dmode, x1, x2, y1, y2)
	}

	# make sure the user did not input a plio file
	if( rg_ftype(region, 0, 0) ==2 )
	    call error(1, "can't make a pl mask using only a pl mask as input")

	# determine if we have a reference image or dimensions
	if( imaccess(imname, 0) == YES ){
	    doimage = YES
	    # allow mask name to default to image
	    call rootname(imname, plname, EXT_PL, SZ_PATHNAME)
	}
	else{
	    # pick out the dimensions from the string
	    ndims = 1
	    ip = 1
	    while( TRUE ){
		nchar = ctoi(imname, ip, axislen[ndims])
		if( nchar ==0 ) break
		if( ndims > MAX_DIMS )
		    call error(1, "too many pl dimensions specified")
		ndims = ndims + 1
	    }
	    doimage = NO
	}

	# must have a valid plname
	if( streq(plname, "") )
	    call error(1, "requires a mask file name")

	# must have a valid plname
	if( streq(plname, "NONE") )
	    call error(1, "requires a mask file name")

	# add the extension, if necessary
	call addextname(plname, EXT_PL, SZ_FNAME)

	# check for already-existing file
	call clobbername(plname, tempname, clobber, SZ_FNAME)

	# create the mask
	if( doimage == YES ) {
	    # open the reference image
	    im = immap(imname, READ_ONLY, 0)
	    # create the PMIO file
	    pl =  rg_pmcreate(region, im, title)
	    # create the mask header
	    call enc_plhead(plname, "region", imname,
			    IM_LEN(im,1), IM_LEN(im,2),
			    0.0, title, s, SZ_PLHEAD)
	    # save mask in a file
	    call pm_savef(pl, tempname, s, 0)
	    # close the reference image
	    call imunmap(im)
	    # display as necessary
	    if( disp >0 )
	        call disp_plhead(s)
	    if( disp >1 )
		call rg_pldisp(pl, ncols, nrows, x1, x2, y1, y2)
	    # close the pixel mask
	    call pm_close(pl)
	} else {
	    # create the PLIO file
	    pl =  rg_plcreate(region, axislen, title)
	    # create the mask header
	    call enc_plhead(plname, "region", "",
			    axislen[1], axislen[2],
			    0.0, title, s, SZ_PLHEAD)
	    # save mask in a file
	    call pl_savef(pl, tempname, s, 0)
	    # display as necessary
	    if( disp >0 )
	        call disp_plhead(s)
	    if( disp >1 )
		call rg_pldisp(pl, ncols, nrows, x1, x2, y1, y2)
	    # close the pixel mask
	    call pl_close(pl)
	}

	# rename mask file, if necessary
	call finalname(tempname, plname)

	# free the title
	call mfree(title, TY_CHAR)
end
.fi
.sp
.in -12
BUGS
.sp
SEE ALSO
.in4
regions (a description of the ASCII region descriptor, in the spatial
doc directory), rg_pllims.
