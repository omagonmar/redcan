include	"parser.h"


# FC_PARSE - Parser driver routine for the parser generated by xyacc.
# It returns ERR if errors are found in the input file, and OK for no
# errors. The code generation buffers MUST be allocated before calling
# this procedure.

int procedure fc_parse (line)

char	line[ARB]		# line to parse

int	len, dummy

include	"lexer.com"
include	"parser.com"

int	strlen()
int	fc_parser()
extern	fc_lexer()

begin
	# Get input line length
	len = strlen (line)

	# Allocate buffer to store the input line in the lexer common,
	# and copy the input line into it. This buffer is necessary
	# because the parser generated by XYACC expects a file descriptor
	# (integer) as the input stream, which in turn is passed to the
	# lexer, instead of a line.
	call malloc (lex_line, len, TY_CHAR)
	call strcpy (line, Memc[lex_line], len)

#call eprintf ("fc_parse: line=(%s), lex_line=(%s)\n")
#call pargstr (line)
#call pargstr (Memc[lex_line])

	# Initialize the lexer common variables.
	lex_pos = 1
	call strcpy ("", lex_id, SZ_LINE)

	# Initialize the parser common variables.
	par_nwarnings = 0
	par_nerrors   = 0

	# Parse the input stream. The returned value (ERR|OK) is not
	# used since the error counter is used to determine if there
	# were errors, either syntatic or semantic.
	dummy = fc_parser (INDEFI, false, fc_lexer)

#call eprintf ("fc_parse: after fc_parser lex_line=%x (%s)\n")
#call pargi (lex_line)
#call pargstr (Memc[lex_line])

	# Free lexer line since it's not needed anymore
	call mfree (lex_line, TY_CHAR)

	# Return error code acording to the error counter
	if (par_nerrors != 0)
	    return (ERR)
	else
	    return (OK)
end
