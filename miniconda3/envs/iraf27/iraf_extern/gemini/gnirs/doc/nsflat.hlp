.help nsflat March2012 gemini.gnirs
.ih
NAME
nsflat -- Derive flat field and bad pixel mask data
.ih
USAGE
nsflat lampson
.ih
PARAMETERS
.ls lampson
List of input spectral flats taken with the lamps on (shutter open).
.le
.ls darks = ""
List of input dark images.  Darks are subtracted from the flats and should
be the same exposure time.  Darks are also used to identify bad pixels.
.le
.ls flatfile = ""
Output normalized flat field image.  If not specified, the output file
will be the first input flat with "_flat" appended.
.le
.ls darkfile = ""
File to save combined darks to, if specified (used by NSSLITFUNC).
.le
.ls fl_corner = no
Zero "corner" regions of darks, if given in the MDF (eg for XD data).
.le
.ls fl_save_darks = no
Save the processed darks?  Typically, NSPREPARE does not associate
darks with an MDF, so the files listed in \fIdarks\fR are uncut.  If
this flag is set then the dark data, associated with an MDF and cut if
required, are saved as files with a "c" prefix.  They can then be
re-used with NSFLAT (via \fIdarks\fR) for other observations (with the
same configuration), saving the need to reprocess the dark observations
(used to optimize pipeline processing).
.le
.ls flattitle = "default"
Image title for \fIflatfile\fR.
.le
.ls bpmtitle = "default"
Image title for \fIbpmfile\fR.
.le
.ls bpmfile = "default"
Image name for output PL \fIbpmfile\fR.  If set to "default", the output
bad pixel mask will be the first input file name with "_bpm.pl" appended.
The output bad pixel mask has the same size as the original raw data files
so that it may be used as input for NSPREPARE.
.sp
Bad pixels have a value of 1.  Pixels in the input \fIlampson\fR
images that exceed the non-linear limit in the header will be flagged
with the value 2, and saturated pixels flagged with 4.  The values are
combined with a logical OR, meaning that a bad pixel that was
saturated will have a value of 5 in the output DQ plane.
.sp
For cross-dispersed spectra, the bpm file combines all the DQ frames of
the different spectra orders (extensions).
.le
.ls process = "auto" (auto|fit|median|trace)
Flat fields are calculated by comparing exposure data with a smoothed
version of the same data.  The default ("auto") selects the best option 
based on the datatype (currently \fIprocess\fR=fit for all data).  Hence,
\fIprocess\fR="auto" and \fIprocess\fR="fit" are identical (as of v1.9).
In this case, the smoothed data are generated by fitting a curve to the 
data projected along the spatial direction.  It is also possible to use 
2D median filtering (\fIprocess\fR=median).  \fIprocess\fR=trace will 
trace each aperture with APFLATTEN (previously used for cross-dispersed 
data), but this mode produces very poor results and is not recommended.
.le
.ls statsec = "default"
Image section to use for statistics.  If set to "MDF", then the area defined
by the MDF will be used. Defaults are "[*,*]" for NIRI, "MDF" for all other
data.
.le
.ls fitsec = "default"
Area to project for fitting in the dispersion direction.  If set to "MDF"
then the area defined by the MDF will be used. Defaults are "[*,*]" for
NIRI, "MDF" for all other data.
.le
.ls thr_flo = 0.35
Lower threshold for computing flat field normalization and identifying
bad pixels, as a fraction of the median value in the frame (with
bad pixels ignored).  The median is only used for computing the limits;
\fInormstat\fR is used to compute the normalization constant.  
.le
.ls thr_fup = 1.25
Upper threshold for computing flat field normalization and identifying
bad pixels, as a fraction of the median.
.le
.ls thr_dlo = -20.
Lower threshold for identifying bad pixels in the darks with the same 
exposure times as the short flats. In ADU.
.le
.ls thr_dup = 100.
Upper threshold for identifying bad pixels in the darks with the same
exposure times as the short flats. In ADU.
.le
.ls fl_inter = no
Select interactive use?
.le
.ls fl_range = no
Set threshold ranges interactively (if \fIfl_inter+\fR)?
.le
.ls fl_fixbad = yes
If \fIfl_fixbad\fR = yes, NSFLAT will replace bad pixels in the output
flat field image with the constant value defined by \fIfixvalue\fR.
This prevents bad pixels with values close to 0 from causing problems
in images subsequently divided by the flat.  If \fIfl_vardq\fR is set
to "no", bad pixels cannot be fixed and \fIfl_fixbad\fR will be reset
to no.
.le
.ls fixvalue = 1.0
If \fIfl_fixbad\fR = yes, NSFLAT will use this value to fix bad
pixels in the output flat.  If \fIfixvalue\fR = 0, make sure that
later divisions by the flat handle divide-by-zero errors properly.
.le
.ls function = "spline3"
Fitting function for fitting the illumination pattern in the dispersion
direction.
.le
.ls order = -1
If \fIprocess\fR=fit (or auto, if appropriate), this parameter defines
the order of the polynomial fitting function, or the number of spline
segments if \fIfunction\fR is spline3.
.sp
If \fIprocess\fR=trace then this parameter fixes the polynomial order
used to fit the traced spectrum.
.sp
If set to -1, the order will be set according to the filter and grism.
The order is set to 20 for most filters, but at K, where the flat
drops off steeply at the ends, the order is set to 45.
.le
.ls normstat = "midpt" (mean|midpt)
Statistic used to determine the normalization factor when fine-tuning
the normalization after dividing by the illumination function and identifying
bad pixels.
.le
.ls combtype = "default" (default|average|median)
Type of combining operation performed on the input \fIlampson\fR 
and \fIdark\fR images.  Combining is disabled if only a single input 
image is specified.
.le
.ls rejtype = "ccdclip" (none|minmax|ccdclip|crreject|sigclip|avsigclip|pclip)
Type of rejection operation performed when combining the input images.
The algorithms are described in the help for 
IMCOMBINE. The rejection choices are:
.nf
      none - No rejection
    minmax - Reject the nlow and nhigh pixels
   ccdclip - Reject pixels using CCD noise parameters
  crreject - Reject only positive pixels using CCD noise parameters
   sigclip - Reject pixels using a sigma clipping algorithm
 avsigclip - Reject pixels using an averaged sigma clipping algorithm
     pclip - Reject pixels using sigma based on percentiles
.fi
.le
.ls masktype = "goodvalue"  (none|goodvalue)
Type of pixel masking to use.  See GEMCOMBINE.
.le
.ls maskvalue = 0.
Mask value used with the \fImasktype\fR parameter.  See GEMCOMBINE.
.le
.ls scale = "none" (none|mode|median|mean|exposure|@<file>|!<keyword>)
Multiplicative image scaling to be applied when combining the input
images. The choices are none, multiply
by the reciprocal of the mode, median, or mean of the specified statistics
section, multiply by the reciprocal of the exposure time in the image header,
multiply by the values in a specified file, or multiply by a specified
image header keyword. When specified in a file the scales must be one per
line in the order of the input images.
.le
.ls zero = "none" (none|mode|median|mean|@<file>|!<keyword>)
Additive zero level image shifts to be applied when combining the
input images. The choices are none, add
the negative of the mode, median, or mean of the specified statistics
section, add the values given in a file, or add the values given by an
image header keyword. When specified in a file the zero values must be one
per line in the order of the input images. File or keyword zero offset
values do not allow a correction to the weights.
.le
.ls weight = "none" (none|mode|median|mean|exposure|@<file>|!<keyword>)
Weights to be applied during the final averaging. The choices are none,
the mode, median, or mean of the specified statistics section, the exposure
time, values given in a file, or values given by an image header keyword.
When specified in a file the weights must be one per line in the order of
the input images and the only adjustment made by the task is for the number of
images previously combined. In this case the weights should be those
appropriate for the scaled images which would normally be the inverse
of the variance in the scaled image.
.le

.ce
Rejection Algorithm Parameters
.ls lthreshold = INDEF, hthreshold = INDEF
Low and high thresholds to be applied to the input pixels. This is done
before any scaling, rejection, and combining. If INDEF the thresholds
are not used.
.le
.ls nlow = 1,  nhigh = 1 (minmax)
The number of low and high pixels to be rejected by the "minmax" algorithm.
These numbers are converted to fractions of the total number of input images
so that if no rejections have taken place the specified number of pixels
are rejected while if pixels have been rejected by masking, thresholding,
or nonoverlap, then the fraction of the remaining pixels, truncated
to an integer, is used.
.le
.ls nkeep = 0
The minimum number of pixels to retain or the maximum number to reject
when using the clipping algorithms (ccdclip, crreject, sigclip,
avsigclip, or pclip). When given as a positive value this is the minimum
number to keep. When given as a negative value the absolute value is
the maximum number to reject. The latter is in addition to pixels
missing due to non-overlapping offsets, bad pixel masks, or thresholds.
.le
.ls mclip = yes (ccdclip, crreject, sigclip, avsigclip)
Use the median as the estimate for the true intensity rather than the
average with high and low values excluded in the "ccdclip", "crreject",
"sigclip", and "avsigclip" algorithms? The median is a better estimator
in the presence of data which one wants to reject than the average.
However, computing the median is slower than the average.
.le
.ls lsigma = 3., hsigma = 3. (ccdclip, crreject, sigclip, avsigclip, pclip)
Low and high sigma clipping factors for the "ccdclip", "crreject", "sigclip",
"avsigclip", and "pclip" algorithms. They multiply a "sigma" factor
produced by the algorithm to select a point below and above the average or
median value for rejecting pixels.  See help pages for IMCOMBINE for details.
.le
.ls snoise = "0.0" (ccdclip, crreject)
Sensitivity noise as a fraction.  See help pages for IMCOMBINE for details.
.le
.ls sigscale = 0.1 (ccdclip, crreject, sigclip, avsigclip)
This parameter determines when Poisson corrections are made to the
computation of a sigma for images with different scale factors.
See help pages for IMCOMBINE for details.
.le
.ls pclip = -0.5 (pclip)
Percentile clipping algorithm parameter.  See help pages for IMCOMBINE 
for details.
.le
.ls grow = 0.0
Radius in pixels from a rejected pixel for additional pixels to be rejected 
in an image. This applies only to
pixels rejected by one of the rejection algorithms and not the masked or
threshold rejected pixels.  See help pages for IMCOMBINE for details.
.le

.ce
Additional Median Filtering Parameters (\fIprocess\fR=median)
.ls box_width = 20
Median box width (spatial pixel extent).
.le
.ls box_length = 1
Median box length (pixel extent in the dispersion direction).
.le

.ce
Additional APFLATTEN Parameters (\fIprocess\fR=trace)
.ls trace = ""
Reference file to trace for aperture position.
.le
.ls traceproc = "none" (none|left|right|centre|smooth)
Preprocessing for the trace image.  This allows a single, repeatable 
pinhole to be selected when several are present in the pinhole image.
The "left" and "right" values weight the data with a sloping function to
select the pinhole to one side of the aperture; "smooth" convolves the
data with a broad gaussian; "centre" adds the original data back on top of
the smoothed gaussian, weighting the central peak.

In all cases, the identification of XD data will be more reliable if
the extensions have been generated with \fIfl_corner=yes\fR in NSCUT.
.le
.ls threshold = 100
Threshold for aperture detection when tracing.
.le
.ls aptable = "gnirs$data/apertures.fits"
A table that defines appropriate values for the parameters (column
names and default values in parentheses): apall.line (apline, 1);
apflatten.threshold (apthresh, INDEF); apflatten.order (florder,
\florder\fR); apall.t_sample (sdsample, "*"); apflatten.sample
(apsample, "*"); apall.upper and apall.lower (apupper, \fIap_upper\fR
and aplower, \fIap_lower\fR); apall.b_sample (bgsample, "*").  Table
rows are selected using prism, decker, slit and order values.
.sp
The table also includes an apshift column, used by NSSDIST.
.le
.ls database = ""
Directory for files containing trace data.  If undefined, 
\fIgnirs.database\fR is used.
.le
.ls apsum = 10
Number of dispersion lines to sum or median in APALL (tracing
aperture) and APFLATTEN (fitting aperture).
.le
.ls tr_step = 10
Tracing step in APALL.
.le
.ls tr_nlost = 3
Number of consecutive steps that can fail in APALL before tracing is aborted.
.le
.ls tr_function = "legendre"
Function to fit to trace.
.le
.ls tr_order = 5
Order of \fItr_function\fR.
.le
.ls tr_naver = 1
Number of steps to average or median in trace.
.le
.ls tr_niter = 0
Number of rejection iterations while fitting to trace.
.le
.ls tr_lowrej = 3.
Lower rejection threshold when iterating during trace fit.
.le
.ls tr_highrej = 3.
Upper rejection threshold when iterating during trace fit.
.le
.ls tr_grow = 0.
Augmented rejection radius when iterating during trace fit.
.le
.ls ap_lower = -30
Start of aperture relative to trace centre.
.le
.ls ap_upper = 30
End of aperture relative to trace centre.
.le

.ce
Additional NSFLAT Parameters
.sp
.ls fl_vardq = yes
Generate variance and data quality (bad pixel map) planes in the 
final output image?
.le
.ls logfile = ""
Name of logfile. The default value makes the task use the
logfile defined by niri.logfile.
.le
.ls verbose = yes
Print actions to screen.
.le
.ls status = 0
Exit status will be non-zero if the procedure halted with an
error. This parameter is always set by the task, and should
not be modified by the user.
.le

.ce
Parameters from NSHEADERS
.sp
The following values are read from GNIRS.NSHEADERS
.ls sci_ext
Name of science extension
.le
.ls var_ext
Name of variance extension
.le
.ls dq_ext
Name of data quality extension
.le
.ls key_instrument
Header keyword for instrument name.
.le
.ls key_section
Header keyword for image section(s) to cut
.le
.ls key_exptime
Header keyword for exposure time (s)
.le
.ls key_filter
Header keyword for filter
.le
.ls key_arrayid
Header keyword for array ID
.le
.ls key_gain
Header keyword for gain (e-/ADU)
.le
.ls key_ron
Header keyword for read noise (e-)
.le
.ls key_sat
Header keyword for saturation (ADU)
.le
.ls key_nonlinear
Header keyword for non-linear regime (ADU)
.le
.ls key_cut_section
Header keyword for image section that was cut
.le
.ls key_dispaxis
Header keyword for dispersion axis
.le
.ls key_prism
Header keyword for prism
.le
.ls key_decker
Header keyword for decker
.le
.ls key_fpmask
Header keyword for focal plane mask (slit)
.le
.ls key_mode
Header keyword for reduction mode (value will be LS, IFU, or XD).  Selects
fit type if \fIprocess="auto"\fR.
.le

.ih 
DESCRIPTION 
NSFLAT produces a normalized flat-field image and a bad pixel mask.
It can work on data with a single science extension or with multiple 
extensions (such as cross-dispersed and IFU data). \fIprocess\fR="auto"
will select the best processing mode for a given data type (as of v1.9,
this is "fit" for all data).
.sp
Dark images without MDFs will automatically be processed using the MDF
associated with the \fIlampson\fR images.
.sp
The flats and darks are combined separately using IMCOMBINE and using
a region for statistics as defined by \fIstatsec\fR.  The combined
dark image is subtracted from the combined lamp image before fitting
the illumination pattern and normalizing.
.sp
When \fIprocess\fR=fit (or "auto"), the fitting function is defined by the
parameter \fIfunction\fR and the order of the fitting
function (or the number of spline sections).  The \fIorder\fR and
\fIstatsec\fR can be set to -1 and default, respectively, and NSFLAT
will then use the best values for a given grism and order sorting
filter.  The fit is only performed over the one-dimensional region
defined by \fIfitsec\fR, and the flat is only valid within that
region.  Pixels outside \fIfitsec\fR are flagged as bad and set to 1
in the flat field image.  The fit is performed as follows: all the
rows (in the spatial direction) are averaged and then smoothed by
fitting a high order polynomial or spline function.  Each row is then
normalized by dividing by this fit.  Bad pixels are then identified
and a final adjustment to the normalization is done using
\fInormstat\fR within the range defined by \fIthr_flo\fR and
\fIthr_fup\fR (which can be set interactively using
\fIfl_inter+\fR).
.sp
When \fIprocess\fR=trace the APFLATTEN task is used.  \fIaptable\fR is
used to provide different aperture parameters for each order.
.sp
When \fIprocess\fR=median the data are smoothed using a 2D running box
median.
.sp
The dark images are also used to augment the bad pixel mask.
Pixels in the combined dark with values of less than \fIthr_dlo\fR
or greater than \fIthr_dup\fR ADU are classified as bad.  If
\fIfl_inter\fR=yes, then these levels are set interactively using
histograms of pixel values.
.sp
The bad pixel mask is stored in the data quality plane and also
written as a separate PL file \fIbpmfile\fR.  The output PL file has
the same size as the original raw data files so that it can be used as
input to NSPREPARE (this is true even for data that have been cut into
different extensions - the bpm is the "or" combination of overlapping
regions).
.sp
If \fIfl_vardq\fR = "yes", the output flatfield contains VAR and DQ
(strictly, \fInsheaders.var_ext\fR and \fInsheaders.dq_ext\fR)
extensions with variance and data quality values for the associated
science data.  The variance image is the sum of the variances of the
combined lampson and dark images, normalized by the square of the flat
field normalization constant.
.sp
.ce
Signal to Noise Calculations
.sp
The task displays the mean value and, if \fIfl_vardq+\fR, the S/N for
each flat generated.
.sp
First, the median and standard deviation of all points in the flat
except bad pixels are measured.  The mean is then calculated from all
those points which are within four standard deviations of the median
(again excluding bad pixels).
.sp
Signal-to-noise is calculated by measuring the mean variance value in
the same way and then dividing the data mean by the square root of the
mean variance.  If the mean variance is smaller than 10^-6 then the
division is not calculated and ">1000" displayed for the S/N.
.ih
EXAMPLES
1. To make a bad pixel mask and flat from two lists of nsprepared 
images, with default parameters and clipping the ends:
.sp
.nf
    cl> nsflat @flatfiles darks=@darkfiles statsec=[200:900,*]
.fi
.sp
2.  To make a flat interactively:
.sp
.nf
    cl> nsflat nirisky* fl_inter+ 
.fi
.ih
BUGS AND LIMITATIONS
For IFU data, NSFLAT has to be used in conjunction with NSSLITFUNCTION
(via \fInsslitfunction.flat\fR) in order to restore the inter-slice
variations. It is not sufficient to divide IFU data by the output flat
from NSFLAT because all the extensions are normalized individually to
unity, so the throughput differences between image slices would remain
in the science data. If necessary, it is possible to run NSSLITFUNCTION
on the same processed lamp flat(s) as NSFLAT, in place of twilight(s).
.ih
SEE ALSO
nsprepare, nscut, imcombine, nsslitfunc
.endhelp
