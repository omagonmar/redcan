# Copyright(c) 1992 Association of Universities for Research in Astronomy Inc.

include	<fset.h>
include	<imhdr.h>

# IRFFTES -- Test the 2-D FFT procedures FFFT_B and IFFT_B based on  
# the NCARFFT library

procedure t_irfftes ()

# This is a test program for the 2-D FFT procedures FFFT_B and IFFT_B. 
# The test data are generated by a separate procedure FFTDATA.
# The interface programs to NCARFFT lib are in the file FFT_NCAR.X.
# Link to:  fftdata.o fft_ncar.o /usr/stsci/stsdasx/lib/libapplib.a 
#
# Real data are forward FFTed, then inverse FFTed. So three data files will be 
# created. For the complex data obtained after forward FFT, their magnitudes
# are written to a file.
#
# N.B. FFT size is arbitrary; complex <=> complex without transposition.
#
# Some procedures are in outx.x

pointer	sp 			# Memory stack pointer
pointer	outm			# Output image name (common part) string pointer
pointer	outmr, outmc, outmd	# Output image name string pointers
pointer	omr, omc, omd		# Output image descriptors

int	npix, nlin 	# Array size in each dimension
int	narr	 	# Total number of points of array
pointer	pt_r		# Real data array pointer
pointer	pt_c		# Pointer of complex array output from forward FFT

int	line, outline	# Line number
pointer	olr, olc, old	# Line pointers

long	cpu_o		# Old CPU time
int	initial		# Display control

pointer	work		# Pointer of fft working space structure

int	fstati(), clgeti()
pointer	immap(), impl2r()

define	NDIM	2	# 2-D array

begin
	# For properly output messages
	if (fstati (STDOUT, F_REDIR) == NO) 
	    call fseti (STDOUT, F_FLUSHNL, YES)

	# Initialize the dynamic memory stack
	call smark (sp)
	call salloc (outm, SZ_FNAME, TY_CHAR)
	call salloc (outmr, SZ_FNAME, TY_CHAR)
	call salloc (outmc, SZ_FNAME, TY_CHAR)
	call salloc (outmd, SZ_FNAME, TY_CHAR)
	
	call printf ("Generating output filenames\n")
	# Get output image names
	call clgstr ("output", Memc[outm], SZ_FNAME)

	call sprintf (Memc[outmr], SZ_FNAME, "%s r")
	    call pargstr (Memc[outm])
	call sprintf (Memc[outmc], SZ_FNAME, "%s c")
	    call pargstr (Memc[outm])
	call sprintf (Memc[outmd], SZ_FNAME, "%s d")
	    call pargstr (Memc[outm])

	# Get array size in each dim
	npix =  clgeti ("n1")
	nlin =  clgeti ("n2")

	call printf ("Opening output files\n")
	# Open output images
  	omr = immap (Memc[outmr], NEW_IMAGE, 0)	# Hold data before FFT
  	omc = immap (Memc[outmc], NEW_IMAGE, 0)	# Hold data after forward FFT
  	omd = immap (Memc[outmd], NEW_IMAGE, 0)	# Hold data after f. & invse FFT

	# Set image header parameters
	IM_NDIM(omr) = NDIM 
	IM_NDIM(omc) = NDIM 
	IM_NDIM(omd) = NDIM 
	IM_LEN(omr,1) = npix
	IM_LEN(omc,1) = npix
	IM_LEN(omd,1) = npix
	IM_LEN(omr,2) = nlin
	IM_LEN(omc,2) = nlin
	IM_LEN(omd,2) = nlin
	IM_PIXTYPE(omr) = TY_REAL 
	IM_PIXTYPE(omc) = TY_REAL 
	IM_PIXTYPE(omd) = TY_REAL 

	# Memory allocation for the real data array before FFT
	narr = npix * nlin
	call malloc (pt_r, narr, TY_REAL)

	# Output initial CPU time
	initial = 0
	call discpu (cpu_o, initial)

	# FFT initialization, including dynamic memory allocation for the
	# complex array holding input/output for FFT, calculate 
	# trigonometrical fn tables, and allocate some working space for FFT.
	call printf ("Initializing FFT\n")
	call fft_b_ma (pt_c, npix, nlin, work)

	# Output accumulated CPU time
	initial = 1
	call discpu (cpu_o, initial)

	call printf ("Generating data\n")
	# Generate test data before FFT
	call fftdata (Memr[pt_r], npix, nlin)

	# Output accumulated CPU time
	call discpu (cpu_o, initial)

	call printf ("Writing output file before FFT\n")
	# Write	output data to image, before FFT
	do line = 1, nlin {
	    # Allocate the output image line
	    olr = impl2r (omr, line)

	    # Assign values to each line
	    call outr_b (Memr[pt_r], Memr[olr], npix, line)
	}

	# Output accumulated CPU time
	call discpu (cpu_o, initial)

	call printf ("Calling forward FFT\n")
	# Calling forward FFT
	call ffft_b (Memr[pt_r], Memx[pt_c], npix, nlin, work)
	
	# Output accumulated CPU time
	call discpu (cpu_o, initial)

	call printf ("Writing output file after forward FFT\n")
	# Write	output data to image after forward FFT, taking the magnitude
	# of complex. Image max is centered by shifting by (npix/2,nlin/2).
	outline = 1 + nlin / 2
	do line = 1, nlin {
	    if (outline > nlin)
	        outline = outline - nlin
	
	    # Allocate the output image line
	    olc = impl2r (omc, outline)

            # Assign values to each line
	    call outc_b (Memx[pt_c], Memr[olc], npix, line)
	    outline = outline + 1
	}

	# Output accumulated CPU time
	call discpu (cpu_o, initial)

	call printf ("Calling inverse FFT\n")
	# Calling inverse FFT 
	call ifft_b (Memx[pt_c], Memr[pt_r], npix, nlin, work)

	# Output accumulated CPU time
	call discpu (cpu_o, initial)

	call printf ("Writing output file after double FFT\n")
	# Write	output data to image, after double FFT
	do line = 1, nlin {
	    # Allocate the output image line
	    old = impl2r (omd, line)

	    # Assign values to each line
	    call outr_b (Memr[pt_r], Memr[old], npix, line)
	}

	# Output accumulated CPU time
	call discpu (cpu_o, initial)

	call printf ("File output finished\n")

	# Deallocate memory for the real data array and FFT
	call mfree (pt_r, TY_REAL)
	call fft_b_mf (pt_c, work)

	# Close the image
	call imunmap (omr)
	call imunmap (omc)
	call imunmap (omd)

	# Free dynamic memory stack
	call sfree (sp)
end

# Dispay initial or accumulated CUP time

procedure discpu (cpu_o, initial)

long	cpu_o		# Old CPU time
int	initial		# 0: Display initial CPU time, accumulated one otherwise

real	cpu		# Accumulated CPU time in seconds

long	cputime()	# Get CPU time in 1000th seconds

begin
	cpu = 0.001 * cputime (cpu_o)
	if (initial == 0)
	    call printf ("%8.2f : Initial CPU time in secs.\n")
	else
	    call printf ("%8.2f : Accumulated CPU time in secs.\n")
        call pargr (cpu)
end
